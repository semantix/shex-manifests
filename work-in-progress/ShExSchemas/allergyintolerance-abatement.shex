PREFIX fhir: <http://hl7.org/fhir/> 
PREFIX fhirvs: <http://hl7.org/fhir/ValueSet/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
BASE <http://hl7.org/fhir/shape/>


# When the allergy or intolerance resolved
<allergyintolerance-abatement> EXTENDS @<Extension> CLOSED {   

    a [fhir:allergyintolerance-abatement];
    fhir:nodeRole [fhir:treeRoot]?;
    fhir:v @<Extension.url> AND
    	{fhir:value ["http://hl7.org/fhir/StructureDefinition/allergyintolerance-abatement"]}; 
    fhir:value (@<dateTime>  OR 
    			@<Age>  OR 
    			@<Period>  OR 
    			@<Range>  OR 
    			@<string> )  AND { rdf:type IRI } ; 
    ^fhir:extension { a [fhir:AllergyIntolerance]
    		}
}  

#---------------------- Data Types -------------------

# Primitive Type dateTime
<dateTime> EXTENDS @<PrimitiveType> CLOSED {   

    a [fhir:dateTime];
    fhir:nodeRole [fhir:treeRoot]?;
    fhir:v @<dateTime.value>?;              # Primitive value for dateTime
}  

# Primitive Type string
<string> EXTENDS @<PrimitiveType> CLOSED {   

    a [fhir:string];
    fhir:nodeRole [fhir:treeRoot]?;
    fhir:v @<string.value>?;                # Primitive value for string
}  

# Time range defined by start and end date/time
<Period> EXTENDS @<DataType> CLOSED {   

    a [fhir:Period];
    fhir:nodeRole [fhir:treeRoot]?;
    fhir:start @<Period.start>?;            # Starting time with inclusive 
                                            # boundary 
    fhir:end @<Period.end>?;                # End time with inclusive boundary, 
                                            # if not ongoing 
} AND (

# Constraint: UniqueKey:per-1
# Human readable:If present, start SHALL have a lower or equal value than end
# XPath:not(exists(f:start/@value)) or not(exists(f:end/@value)) or (xs:dateTime(f:start/@value) <= xs:dateTime(f:end/@value))
# Constraint:start.hasValue().not() or end.hasValue().not() or (start <= end)
# ShEx:

 NOT { fhir:start  . } OR  NOT { fhir:end  . } OR ({ fhir:start { fhir:v MaxInclusive { fhir:end } }  })

)
 

# Set of values bounded by low and high
<Range> EXTENDS @<DataType> CLOSED {   

    a [fhir:Range];
    fhir:nodeRole [fhir:treeRoot]?;
    fhir:low @<Range.low>?;                 # Low limit
    fhir:high @<Range.high>?;               # High limit
} AND (

# Constraint: UniqueKey:rng-2
# Human readable:If present, low SHALL have a lower value than high
# XPath:not(exists(f:low/f:value/@value)) or not(exists(f:high/f:value/@value)) or (number(f:low/f:value/@value) <= number(f:high/f:value/@value))
# Constraint:low.value.empty() or high.value.empty() or (low <= high)
# ShEx:

 NOT { fhir:low fhir:value {fhir:v .} }  OR  NOT { fhir:high fhir:value {fhir:v .} }  OR ({ fhir:low { fhir:v MaxInclusive { fhir:high } }  })

)
 

# A duration of time during which an organism (or a process) has existed
<Age> EXTENDS @<Quantity> CLOSED {   

    a [fhir:Age];
    fhir:nodeRole [fhir:treeRoot]?;
} AND (

# Constraint: UniqueKey:age-1
# Human readable:There SHALL be a code if there is a value and it SHALL be an expression of time.  If system is present, it SHALL be UCUM.  If value is present, it SHALL be positive.
# XPath:(f:code or not(f:value)) and (not(exists(f:system)) or f:system/@value='http://unitsofmeasure.org') and (not(f:value/@value) or f:value/@value >=0)
# Constraint:(code.exists() or value.empty()) and (system.empty() or system = %ucum) and (value.empty() or value.hasValue().not() or value > 0)
# ShEx:

({ fhir:code . } OR  NOT { fhir:value {fhir:v .} } ) AND ( NOT { fhir:system {fhir:v .} }  OR ({ fhir:system { fhir:v ['http://unitsofmeasure.org'] }  })) AND ( NOT { fhir:value {fhir:v .} }  OR  NOT { fhir:value  . } OR ({ fhir:value { fhir:v MinExclusive 0 }  }))

)
 

#---------------------- Cardinality Types (OneOrMore) -------------------

#---------------------- Reference Types -------------------

#---------------------- Value Sets ------------------------
